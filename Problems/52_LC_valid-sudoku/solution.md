

- We check every row and every column, not check every element in its row and column, the former check implicitly performs the latter one as well, only for every other element as well.
- The logic is simple but implementation only a slight bit tedious, we first check each row for a duplicate, then each column and we use a frequency array given the size of values of n[i] (We could instead just use a bitset as well, as given in the other solution by me) is just 9 values.  Since we have to check an element in its row and its column which are 2 operations, for every value in the nxn grid, it means that our 2 passes for checking all elements is indeed the smallest number of checks (even if we use some other data structure, we would still need it to check all its values twice for each number). Why does it work ? Because when we check each value's duplicacy in its row, we know that every element in that row only occurs once, so even if we check any given element's column for duplicacy we already know it doesn't repeat in its row, and this means we don't need to worry about a duplicate for an element after we have checked it in any one axis, we only need to check the other axis, so we don't need to store any value and we can just use 1 single array of size 9 to check the rows and then the columns for duplicates. If every row and every column is duplicate free, it means, that every element, doesn't repeat in its row, and every element doesn't repeat in its column, hence our first 2 conditions of the problem are checked.
- Now checking each block, of size 3x3, means we need to check the elements in that block itself, this part can be optimized probably, because it's accessing each element once again, so we traverse the nxn grid 3 times. Anyway, to check this condition, we simply divide the nxn grid into 3x3 blocks, and for each block in each block row and block column we check all its elements. The blocks theirselves have 4 key indices, the start or the top left corner, the top right corner, the bottom left corner and lastly the bottom right corner. If we have these 4 indices for all the blocks, we simply need to traverse the block, we can do that by checking each row and storing the value, since all the elements in the block need to be considered we don't need 2 passes, we can simply traverse the 3x3 block just once, and check all its values.
- '2' - '0' is 2, i.e., all numbers from 0 to 9 come back as the same in ints, however '.'-'0' is -2 in ascii. That is, the ascii position of '.' is 2 behind that if '0' and we are essentially finding the distance between '0' in ascii to 0 to 9, and any other character for that matter, since all of them appear continuously and in the proper order, char - '0' works (i.e., if we had the ascii value of say 4 greater than that of say 5, then '5'-'0' would give something like 4, and for 5 it might be 4, but it would be atleast flipped).

TC is O(m) where m is nxn.